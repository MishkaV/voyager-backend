"""LLM-based generator for country_best_times table."""

from pathlib import Path
from typing import Dict, List

from generators.base_generator import BaseGenerator
from utils.database.country_best_time_repository import (
    CountryBestTime,
    CountryBestTimeRepository,
)
from utils.database.country_repository import Country, CountryRepository
from utils.openai.country_best_time_assignment import (
    CountryBestTimeAssignment,
    CountryBestTimeAssignmentClient,
)
from utils.settings.voyager_settings import VoyagerSeedSettings


class CountryBestTimeGenerator(BaseGenerator):
    """Generator for country_best_times table using LLM."""

    filename = "05_country_best_times.sql"

    def __init__(self, settings: VoyagerSeedSettings):
        """Initialize the generator.

        Args:
            settings: Voyager seed settings for configuration.
        """
        super().__init__(settings)
        self.country_repo = CountryRepository(settings)
        self.country_best_time_repo = CountryBestTimeRepository(settings)
        self.openai_client = CountryBestTimeAssignmentClient(settings)
        print(
            f"[country_best_times] Initialized with batch size: {CountryBestTimeAssignmentClient.BATCH_SIZE}"
        )

    def generate(self, output_path: Path) -> None:
        """Generate country_best_times records using LLM and write directly to database.

        This method:
        1. Fetches all countries from the database
        2. Processes countries in batches using OpenAI
        3. Writes results directly to the country_best_times table

        Args:
            output_path: Path parameter (not used, as we write directly to DB).
        """
        print("[country_best_times] Starting generation...")

        # Fetch all countries
        print("[country_best_times] Fetching countries from database...")
        countries = self.country_repo.get_all()
        print(f"[country_best_times] Found {len(countries)} countries")

        if not countries:
            print("[country_best_times] No countries found in database, skipping generation")
            return

        # Create a mapping of country ISO2 to country ID
        country_iso2_to_id: Dict[str, str] = {
            country.iso2: country.id for country in countries
        }

        # Process countries in batches
        batch_size = CountryBestTimeAssignmentClient.BATCH_SIZE
        total_batches = (len(countries) + batch_size - 1) // batch_size
        print(
            f"[country_best_times] Processing {len(countries)} countries in {total_batches} batch(es) of {batch_size}"
        )

        all_best_time_records: List[CountryBestTime] = []
        processed_countries = 0

        for batch_idx in range(0, len(countries), batch_size):
            batch_countries = countries[batch_idx : batch_idx + batch_size]
            batch_num = (batch_idx // batch_size) + 1

            print(
                f"[country_best_times] Processing batch {batch_num}/{total_batches} ({len(batch_countries)} countries)..."
            )

            try:
                # Call OpenAI to get best times for countries in this batch
                assignments = self.openai_client.get_best_times_for_countries(
                    batch_countries
                )

                # Convert assignments to CountryBestTime records
                batch_records: List[CountryBestTime] = []
                for assignment in assignments:
                    country_id = country_iso2_to_id.get(assignment.country_iso2)
                    if not country_id:
                        print(
                            f"[country_best_times] Warning: Country {assignment.country_iso2} not found in database, skipping"
                        )
                        continue

                    for best_time in assignment.best_times:
                        # Create CountryBestTime record (id will be generated by database)
                        batch_records.append(
                            CountryBestTime(
                                id="",  # Will be generated by database
                                country_id=country_id,
                                title=best_time["title"],
                                description=best_time["description"],
                            )
                        )

                all_best_time_records.extend(batch_records)
                processed_countries += len(batch_countries)

                print(
                    f"[country_best_times] Batch {batch_num} completed: {len(batch_records)} best time records created"
                )

            except Exception as e:
                print(
                    f"[country_best_times] Error processing batch {batch_num}: {e}"
                )
                raise

        # Insert all records into the database
        if all_best_time_records:
            print(
                f"[country_best_times] Inserting {len(all_best_time_records)} best time records into database..."
            )
            try:
                # Use insert_many with upsert handling
                # Note: Supabase will handle ON CONFLICT automatically based on the unique constraint
                inserted = self.country_best_time_repo.insert_many(all_best_time_records)
                print(
                    f"[country_best_times] Successfully inserted {len(inserted)} best time records"
                )
            except Exception as e:
                # If there are duplicate key conflicts, try inserting one by one
                print(
                    f"[country_best_times] Bulk insert failed (possibly due to duplicates), trying individual inserts: {e}"
                )
                inserted_count = 0
                for record in all_best_time_records:
                    try:
                        self.country_best_time_repo.insert(record)
                        inserted_count += 1
                    except Exception as insert_error:
                        # Ignore duplicate key errors
                        if "duplicate" in str(insert_error).lower() or "unique" in str(insert_error).lower():
                            continue
                        raise
                print(
                    f"[country_best_times] Successfully inserted {inserted_count} best time records (some may have been duplicates)"
                )

        print("[country_best_times] Generation completed successfully!")
        print(f"[country_best_times] Statistics:")
        print(f"[country_best_times]   - Countries processed: {processed_countries}")
        print(f"[country_best_times]   - Total best time records: {len(all_best_time_records)}")

